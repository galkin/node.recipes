{"version":3,"sources":["webpack:///../src/pages/use-action.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"wPAQaA,G,UAAe,S,0MAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,cADR,cAGA,wDAAuC,6BAAGC,WAAW,KAAQ,CACzD,KAAQ,eAD2B,qBAAvC,iWAEgY,0BAAYA,WAAW,KAAvB,WAFhY,gBAEoc,0BAAYA,WAAW,KAAvB,UAFpc,KAE4f,0BAAYA,WAAW,KAAvB,SAF5f,8DAGA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,kBADZ,kCAIL,iBAAQ,CACN,GAAM,aACL,0BAAYA,WAAW,MAAvB,cACH,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,myB,wMAsCTJ,EAAWK,gBAAiB","file":"component---src-pages-use-action-mdx-fc45593ee5bd2fc0a983.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/mkt/Development/corets/corets/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"use-action\"\n    }}>{`Use Action`}</h1>\n    <p>{`This package is built on top of `}<a parentName=\"p\" {...{\n        \"href\": \"/use-async\"\n      }}>{`@corets/use-async`}</a>{`. The purpose of this package is to be able to encapsulate any async operation into a standardized handle that can be run on demand and awaited. Example use case: You have an async operation, like send some data to an endpoint, you create an async action and trigger it when the time is right. You don't have to worry about state related things like `}<inlineCode parentName=\"p\">{`running`}</inlineCode>{` indicators, `}<inlineCode parentName=\"p\">{`result`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`error`}</inlineCode>{` handling, etc. It's all available directly on the action.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`yarn add @corets/use-action\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"useaction\"\n    }}><inlineCode parentName=\"h2\">{`useAction`}</inlineCode></h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`import React, { useState } from \"react\"\nimport { useAction } from \"@corets/use-action\"\n\nconst Example = () => {\n  const [likesCount, setLikesCount] = useState(0)\n  const likeAction = useAction(async (count: number) => {\n    // some http magic\n    return count\n  })\n\n  const handleLike = async () => {\n    if ( ! likeAction.running) {\n      const result = await likeAction.run(likesCount + 1)\n\n      if ( ! likeAction.error) {\n        setLikesCount(result)\n        // or\n        setLikesCount(likeAction.result)\n      }\n    }\n  }\n\n  return (\n    <div>\n      { likeAction.running && \"Loading...\"}\n      { likeAction.errored && \\`There was an error: \\${likeAction?.error.toString()}\\` }\n\n      <button onClick={handleLike}>Like {likesCount}</button>\n    </div>\n  )\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}