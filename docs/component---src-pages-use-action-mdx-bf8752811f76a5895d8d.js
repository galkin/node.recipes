(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{ceBa:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return s})),t.d(n,"default",(function(){return b}));var a=t("Fcif"),o=t("+I+c"),i=(t("mXGw"),t("/FXl")),r=t("TjRS"),c=t("SxAF"),s=(t("aD51"),{});void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/pages/use-action.mdx"}});var u={_frontmatter:s},l=r.a;function b(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(i.b)(l,Object(a.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)(c.a,{repository:"use-action",mdxType:"Header"}),Object(i.b)("h1",{id:"use-action"},"Use Action"),Object(i.b)("p",null,"This package is built on top of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/use-async"}),"@corets/use-async"),". The purpose of this package is to be able to encapsulate any async operation into a standardized handle that can be run on demand and awaited. Example use case: You have an async operation, like send some data to an endpoint, you create an async action and trigger it when the time is right. You don't have to worry about state related things like ",Object(i.b)("inlineCode",{parentName:"p"},"running")," indicators, ",Object(i.b)("inlineCode",{parentName:"p"},"result"),", ",Object(i.b)("inlineCode",{parentName:"p"},"error")," handling, etc. It's all available directly on the action."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"yarn add @corets/use-action\n")),Object(i.b)("h2",{id:"useaction"},Object(i.b)("inlineCode",{parentName:"h2"},"useAction")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import React, { useState } from "react"\nimport { useAction } from "@corets/use-action"\n\nconst Example = () => {\n  const [likesCount, setLikesCount] = useState(0)\n  const likeAction = useAction(async (count: number) => {\n    // some http magic\n    return count\n  })\n\n  const handleLike = async () => {\n    if ( ! likeAction.running) {\n      const result = await likeAction.run(likesCount + 1)\n\n      if ( ! likeAction.error) {\n        setLikesCount(result)\n        // or\n        setLikesCount(likeAction.result)\n      }\n    }\n  }\n\n  return (\n    <div>\n      { likeAction.running && "Loading..."}\n      { likeAction.errored && `There was an error: ${likeAction?.error.toString()}` }\n\n      <button onClick={handleLike}>Like {likesCount}</button>\n    </div>\n  )\n}\n')))}void 0!==b&&b&&b===Object(b)&&Object.isExtensible(b)&&!b.hasOwnProperty("__filemeta")&&Object.defineProperty(b,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/pages/use-action.mdx"}}),b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-use-action-mdx-bf8752811f76a5895d8d.js.map