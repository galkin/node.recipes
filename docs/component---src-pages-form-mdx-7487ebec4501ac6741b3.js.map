{"version":3,"sources":["webpack:///../src/pages/form.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-pages-form-mdx-7487ebec4501ac6741b3.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/mkt/Development/corets/corets/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"form\"\n    }}>{`Form`}</h1>\n    <p>{`An opinionated form library for any JavaScript environment, with focus on React and React Native. The main difference between this package and other form libraries out there, is the ability to define a form `}<em parentName=\"p\">{`outside`}</em>{` of your presentation layer and just map it inside a component later on. A form built this way will encapsulate all the necessary logic to handle validation, submission, error handling and so on. This leads to proper encapsulation (separation of concerns), easier testing, composability and reusability.`}</p>\n    <p>{`Quick feature overview:`}</p>\n    <ul>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Runs everywhere`}</strong>{`, including React, React Native`}</li>\n      <li parentName=\"ul\">{`Strong typings from tail to toe, for `}<strong parentName=\"li\">{`Optimal developer experience`}</strong></li>\n      <li parentName=\"ul\">{`Is easily `}<strong parentName=\"li\">{`Testable without any UI`}</strong></li>\n      <li parentName=\"ul\">{`Proper decoupling, treat `}<strong parentName=\"li\">{`Forms as a service`}</strong>{` and reduce complexity inside components`}</li>\n      <li parentName=\"ul\">{`John Wick kind of crazy `}<strong parentName=\"li\">{`Powerful validation`}</strong>{` trough `}<a parentName=\"li\" {...{\n          \"href\": \"/schema\"\n        }}>{`@corets/schema`}</a></li>\n      <li parentName=\"ul\">{`Convenient `}<strong parentName=\"li\">{`Status indicators`}</strong>{` (submitting, errors, dirty fields, and so on)`}</li>\n      <li parentName=\"ul\">{`Tested by an army of killer coding ninja monkeys with a `}<strong parentName=\"li\">{`Test coverage of 100%`}</strong></li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`yarn add @corets/form\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"react\"\n    }}>{`React`}</h2>\n    <p>{`Before you can start using this library inside React, you have to add the `}<a parentName=\"p\" {...{\n        \"href\": \"/use-form\"\n      }}>{`@corets/use-form`}</a>{` package first. It provides a seamless integration through a hooks based API.`}</p>\n    <h2 {...{\n      \"id\": \"quick-start\"\n    }}>{`Quick start`}</h2>\n    <p>{`Use this example as a high level overview of what this library has to offer and whether it suits your personal preference. Here we are going to create a very basic form that has some validation logic and dispatches an HTTP request to a remote endpoint, for processing.`}</p>\n    <p>{`First, let's define our types:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`// sample data type that you want to create through an api call\nexport type User = {\n  uuid: string\n  firstName: string\n  lastName: string\n}\n\n// this is what the form looks like\nexport type CreateUserForm = {\n  firstName: string\n  lastName: string\n}\n\n// meaningful feedback for form consumers\nexport type CreateUserResult = {\n  success?: string\n  error?: string\n  user?: User\n}\n`}</code></pre>\n    <p>{`Next, define a method that is going to call the API:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`// simulate api call for demo purposes\nexport const createUser = async (data: CreateUserForm): Promise<User> => ({ id: 1, ...data })\n`}</code></pre>\n    <p>{`Now we can build the form logic:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { createFormFromSchema } from \"@corets/form\"\nimport { object, value } from \"@corets/schema\"\n\n// a dedicated form factory\nexport const createUserForm = () => {\n  // create a new form with some initial state and validation logic\n  return createFormFromSchema<CreateUserForm, CreateUserResult>(object({\n      firstName: value(\"\").string().min(2).max(20).toTrimmed(),\n      lastName: value(\"\").string().min(2).max(20).toTrimmed()\n    }))\n    // add form handling logic\n    .handler(async (form) => {\n      try {\n        // pretend to make an api call here\n        const user = await createUser(form.get())\n\n        return { success: \"User created\", user }\n      } catch (error) {\n        return { error: \"Could not create user\" }\n      }\n    })\n}\n`}</code></pre>\n    <p>{`Now let's build the form UI:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`import React from \"react\"\n\nimport { useForm } from \"@corets/use-form\"\nimport { useFormBinder } from \"@corets/use-form-binder\"\n\nconst CreateUserForm = () => {\n  // create a new form instance and consume it for proper re-renders when state changes,\n  // also returns a binding utility to connect vanilla input elements with form values\n  const form = useForm(createUserForm)\n\n  // create a form binder for vanilla elements\n  const bind = useFormBinder(form)\n\n  // various form state\n  const errors = form.getErrors()\n  const result = form.getResult()\n\n  return (\n    <form {...bind.form()}>\n      <div>{result?.success || result?.error }</div>\n\n      <div>\n        <input {...bind.input(\"firstName\")} placeholder=\"First name\"/>\n        <div>{form.getErrorsAt(\"firstName\")}</div>\n      </div>\n\n      <div>\n        <input {...bind.input(\"lastName\")} placeholder=\"Last name\"/>\n        <div>{errors.getErrorsAt(\"lastName\")}</div>\n      </div>\n\n      <button {...bind.button()}>Create</button>\n    </form>\n  )\n}\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Note:`}</strong>{` Here we are using a vanilla form binder in order to connect input elements to the form, read more about binders in the next sections.`}</p>\n    <h2 {...{\n      \"id\": \"binders\"\n    }}>{`Binders`}</h2>\n    <p>{`This library is not designed for any specific framework or platform. You should be able to use it everywhere where you can run JavaScript. Considering those limitations, it does not offer any logic on how to connect to the input fields out of the box. Package `}<a parentName=\"p\" {...{\n        \"href\": \"/use-form-binder\"\n      }}>{`@corets/use-form-binder`}</a>{` provides bindings for vanilla HTML elements, but this won't be enough, most likely.`}</p>\n    <p>{`Given the nature of modern frontend development, projects use various component libraries and more often than not you have to write a custom input component. Obviously it is not possible to write one binder to `}<em parentName=\"p\">{`rule them all`}</em>{`. Therefore the most pragmatic approach is to create dedicated binders for various use cases. The good thing is that `}<strong parentName=\"p\">{`It's super easy to roll your own binder!`}</strong></p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://github.com/corets/use-form-binder/blob/master/src/FormBinder.ts\"\n      }}>{`Take a look at how binders are implemented in the @corets/use-form-binder package`}</a></p>\n    <p>{`Here is an example of a very basic, vanilla text field binder:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`\nconst createBinder = (form) => ({\n  input: createInputBinder(form)\n})\n\nconst createInputBinder = (form) => (path) => {\n  return {\n    name: path,\n    value: form.getAt(path),\n    onChange: (e) => form.setAt(path, e.target.value),\n  }\n}\n`}</code></pre>\n    <p>{`That's all there is about it! The best thing is, no matter what component you are going to use, `}<strong parentName=\"p\">{`You can always make it work! ™`}</strong></p>\n    <p>{`Now let's use that binder in our form:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`import React from \"react\"\nimport { createForm } from \"@corets/form\"\nimport { useForm } from \"@corets/use-form\"\n\nconst Example = () => {\n  const form = useForm(() => createForm({ field: \"value\" }))\n  const bind = createBinder(form)\n\n  return <input {...bind.input(\"field\")} />\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"optimisation\"\n    }}>{`Optimisation`}</h2>\n    <p>{`You can reduce the number of re-renders in big forms, by wrapping your UI blocks into the `}<a parentName=\"p\" {...{\n        \"href\": \"/memo\"\n      }}><inlineCode parentName=\"a\">{`<Memo />`}</inlineCode></a>{` component from the `}<a parentName=\"p\" {...{\n        \"href\": \"/memo\"\n      }}>{`@corets/memo`}</a>{` package. Most likely you won't ever need this, since we try to keep the render count as low as possible anyway, but if you do - we've got you covered.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`import React, { useState } from \"react\"\nimport { createForm } from \"@corets/form\"\nimport { useForm } from \"@corets/use-form\"\nimport { Memo } from \"@corets/memo\"\n\nconst Example = () => {\n  const form = useForm(() => createForm({ field1: \"foo\", field2: \"bar\" }))\n  const [someValue, setSomeValue] = useState(\"some state\")\n\n  return (\n    <form>\n      <Memo deps={form.deps(\"field1\")}>\n        This section will only ever re-render when some of shared form properties change,\n        like: \\`submitting\\`, \\`submitted\\` or \\`result\\`, or when one of the field related properties\n        receives a change specific to this field, like: \\`errors\\`, \\`values\\`, \\`changedFields\\` or \\`dirtyFields\\`.\n      </Memo>\n\n      <Memo deps={form.deps([\"field1\", \"field2\"])}>\n        This section will change when one of the two fields receives a relevant change.\n      </Memo>\n\n      <Memo deps={form.deps([\"field1\", \"field2\"], { errors: false })}>\n        This block will NOT re-render if there is an error for one of the two fields.\n      </Memo>\n\n      <Memo deps={[...form.deps([\"field1\", \"field2\"]), someValue]}>\n        Include an aditional, custom, value to the list of dependencies for a re-render.\n      </Memo>\n    </form>\n  )\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"testing\"\n    }}>{`Testing`}</h2>\n    <p>{`When writing unit tests, make sure that you set the `}<a parentName=\"p\" {...{\n        \"href\": \"#formconfig\"\n      }}><inlineCode parentName=\"a\">{`debounce`}</inlineCode></a>{` config property to `}<inlineCode parentName=\"p\">{`0`}</inlineCode>{`. This will disable all the throttling of the state changes, and you will be able to write your tests in a synchronous manner.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { createForm } from \"@corets/form\"\n\nconst form = createForm().config({ debounce: 0 })\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"createform\"\n    }}><inlineCode parentName=\"h2\">{`createForm`}</inlineCode></h2>\n    <p>{`Create a new form instance:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { createForm } from \"@corets/form\"\n\nconst form = createForm({ data: \"foo\" })\n`}</code></pre>\n    <p>{`Create a new form without factory function:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { Form } from \"@corets/form\"\n\nconst form = new Form({ data: \"foo\" })\n`}</code></pre>\n    <p>{`Create a form instance with a specific type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { createForm } from \"@corets/form\"\n\ntype MyForm = { data: string }\n\nconst form = createForm<MyForm>({ data: \"foo\" })\n`}</code></pre>\n    <p>{`Create a new instance with a specific type inferred from initial values:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { createForm } from \"@corets/form\"\n\ntype MyForm = { data: string }\n\nconst initialValues: MyForm = { data: \"foo\" }\nconst form = createForm(initialValues)\n`}</code></pre>\n    <p>{`Specify form result type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { createForm } from \"@corets/form\"\n\ntype MyForm = { data: string }\ntype MyFormResult = { result: string }\n\nconst form = createForm<MyForm, MyFormResult>({ data: \"foo\" })\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"createformfromschema\"\n    }}><inlineCode parentName=\"h2\">{`createFormFromSchema`}</inlineCode></h2>\n    <p>{`Create a new form instance based on a schema definition from the `}<a parentName=\"p\" {...{\n        \"href\": \"/schema\"\n      }}>{`@corets/schema`}</a>{` package. This is a convenience helper that allows you to avoid unnecessary boilerplate code when defining initial values for a form. Instead of creating an object, that adheres to the specific form type, with the initial values, you can define those initial values inside the schema definition itself.`}</p>\n    <p>{`Instead of doing this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { createForm } from \"@corets/form\"\nimport { object, string } from \"@corets/schema\"\n\ntype MyForm = { data: string }\ntype MyFormResult = { result: string }\n\nconst schema = object<MyForm>({\n  data: string().min(2)\n})\nconst initialValues: MyForm = { data: \"foo\" }\nconst form = createForm<MyForm, MyFormResult>(initialValues).schema(schema)\n\n`}</code></pre>\n    <p>{`You can basically do this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { createFormFromSchema } from \"@corets/form\"\nimport { object, value } from \"@corets/schema\"\n\ntype MyForm = { data: string }\ntype MyFormResult = { result: string }\n\nconst schema = object<MyForm>({\n  data: value(\"foo\").string().min(2)\n})\nconst form = createFormFromSchema<MyForm, MyFormResult>(schema)\n`}</code></pre>\n    <p>{`The two examples above are absolutely identical, just the approach is different.`}</p>\n    <h2 {...{\n      \"id\": \"formconfig\"\n    }}><inlineCode parentName=\"h2\">{`Form.config`}</inlineCode></h2>\n    <p>{`Alter form behaviour by providing custom configuration values:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { createForm } from \"@corets/form\"\n\nconst form = createForm()\n  .config({\n    // sanitize on form submit() and validate()? (default: true)\n    sanitize: true,\n    // validate on form submit()? (default: true)\n    validate: true,\n    // validate and sanitize fields immediately after a change? (default: true)\n    reactive: true,\n    // delay invocation of listeners after a change (default: 10)\n    debounce: 10,\n  })\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}