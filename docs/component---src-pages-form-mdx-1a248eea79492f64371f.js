(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{JZdC:function(e,t,r){"use strict";r.r(t),r.d(t,"_frontmatter",(function(){return s})),r.d(t,"default",(function(){return l}));var a=r("Fcif"),n=r("+I+c"),o=(r("mXGw"),r("/FXl")),c=r("BIGe"),s=(r("aD51"),{});void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/pages/form.mdx"}});var i={_frontmatter:s},m=c.a;function l(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(o.b)(m,Object(a.a)({},i,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"form"},"Form"),Object(o.b)("p",null,"An opinionated form library for any JavaScript environment, with focus on React and React Native. The main difference between this package and other form libraries out there, is the ability to define a form ",Object(o.b)("em",{parentName:"p"},"outside")," of your presentation layer and just map it inside a component later on. A form built this way will encapsulate all the necessary logic to handle validation, submission, error handling and so on. This leads to proper encapsulation (separation of concerns), easier testing, composability and reusability."),Object(o.b)("p",null,"Quick feature overview:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Runs everywhere"),", including React, React Native"),Object(o.b)("li",{parentName:"ul"},"Strong typings from tail to toe, for ",Object(o.b)("strong",{parentName:"li"},"Optimal developer experience")),Object(o.b)("li",{parentName:"ul"},"Is easily ",Object(o.b)("strong",{parentName:"li"},"Testable without any UI")),Object(o.b)("li",{parentName:"ul"},"Proper decoupling, treat ",Object(o.b)("strong",{parentName:"li"},"Forms as a service")," and reduce complexity inside components"),Object(o.b)("li",{parentName:"ul"},"John Wick kind of crazy ",Object(o.b)("strong",{parentName:"li"},"Powerful validation")," trough ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"/schema"}),"@corets/schema")),Object(o.b)("li",{parentName:"ul"},"Convenient ",Object(o.b)("strong",{parentName:"li"},"Status indicators")," (submitting, errors, dirty fields, and so on)"),Object(o.b)("li",{parentName:"ul"},"Tested by an army of killer coding ninja monkeys with a ",Object(o.b)("strong",{parentName:"li"},"Test coverage of 100%"))),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"yarn add @corets/form\n")),Object(o.b)("h2",{id:"react"},"React"),Object(o.b)("p",null,"Before you can start using this library inside React, you have to add the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/use-form"}),"@corets/use-form")," package first. It provides a seamless integration through a hooks based API."),Object(o.b)("h2",{id:"quick-start"},"Quick start"),Object(o.b)("p",null,"Use this example as a high level overview of what this library has to offer and whether it suits your personal preference. Here we are going to create a very basic form that has some validation logic and dispatches an HTTP request to a remote endpoint, for processing."),Object(o.b)("p",null,"First, let's define our types:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// sample data type that you want to create through an api call\nexport type User = {\n  uuid: string\n  firstName: string\n  lastName: string\n}\n\n// this is what the form looks like\nexport type CreateUserForm = {\n  firstName: string\n  lastName: string\n}\n\n// meaningful feedback for form consumers\nexport type CreateUserResult = {\n  success?: string\n  error?: string\n  user?: User\n}\n")),Object(o.b)("p",null,"Next, define a method that is going to call the API:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// simulate api call for demo purposes\nexport const createUser = async (data: CreateUserForm): Promise<User> => ({ id: 1, ...data })\n")),Object(o.b)("p",null,"Now we can build the form logic:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createFormFromSchema } from "@corets/form"\nimport { object, value } from "@corets/schema"\n\n// a dedicated form factory\nexport const createUserForm = () => {\n  // create a new form with some initial state and validation logic\n  return createFormFromSchema<CreateUserForm, CreateUserResult>(object({\n      firstName: value("").string().min(2).max(20).toTrimmed(),\n      lastName: value("").string().min(2).max(20).toTrimmed()\n    }))\n    // add form handling logic\n    .handler(async (form) => {\n      try {\n        // pretend to make an api call here\n        const user = await createUser(form.get())\n\n        return { success: "User created", user }\n      } catch (error) {\n        return { error: "Could not create user" }\n      }\n    })\n}\n')),Object(o.b)("p",null,"Now let's build the form UI:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import React from "react"\n\nimport { useForm } from "@corets/use-form"\nimport { useFormBinder } from "@corets/use-form-binder"\n\nconst CreateUserForm = () => {\n  // create a new form instance and consume it for proper re-renders when state changes,\n  // also returns a binding utility to connect vanilla input elements with form values\n  const form = useForm(createUserForm)\n\n  // create a form binder for vanilla elements\n  const bind = useFormBinder(form)\n\n  // various form state\n  const errors = form.getErrors()\n  const result = form.getResult()\n\n  return (\n    <form {...bind.form()}>\n      <div>{result?.success || result?.error }</div>\n\n      <div>\n        <input {...bind.input("firstName")} placeholder="First name"/>\n        <div>{form.getErrorsAt("firstName")}</div>\n      </div>\n\n      <div>\n        <input {...bind.input("lastName")} placeholder="Last name"/>\n        <div>{errors.getErrorsAt("lastName")}</div>\n      </div>\n\n      <button {...bind.button()}>Create</button>\n    </form>\n  )\n}\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Here we are using a vanilla form binder in order to connect input elements to the form, read more about binders in the next sections."),Object(o.b)("h2",{id:"binders"},"Binders"),Object(o.b)("p",null,"This library is not designed for any specific framework or platform. You should be able to use it everywhere where you can run JavaScript. Considering those limitations, it does not ship any logic on how to connect to the input fields out of the box. Package ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/use-form-binder"}),"@corets/use-form-binder")," provides bindings for vanilla HTML elements, but this won't be enough, most likely."),Object(o.b)("p",null,"Given the nature of modern frontend development, projects use various component libraries and more often than not you have to write a custom input component. Obviously it is not possible to write one binder to ",Object(o.b)("em",{parentName:"p"},"rule them all"),". Therefore the most pragmatic approach is to create dedicated binders for various use cases. The good thing is that ",Object(o.b)("strong",{parentName:"p"},"It's super easy to roll your own binder!")),Object(o.b)("p",null,Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/corets/use-form-binder/blob/master/src/FormBinder.ts"}),"Take a look at how binders are implemented in the @corets/use-form-binder package")),Object(o.b)("p",null,"Here is an example of a very basic, vanilla text field binder:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"\nconst createBinder = (form) => ({\n  input: createInputBinder(form)\n})\n\nconst createInputBinder = (form) => (path) => {\n  return {\n    name: path,\n    value: form.getAt(path),\n    onChange: (e) => form.setAt(path, e.target.value),\n  }\n}\n")),Object(o.b)("p",null,"That's all there is about it! The best thing is, no matter what component you are going to use, ",Object(o.b)("strong",{parentName:"p"},"You can always make it work! â„¢")),Object(o.b)("p",null,"Now let's use that binder in our form:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import React from "react"\nimport { createForm } from "@corets/form"\nimport { useForm } from "@corets/use-form"\n\nconst Example = () => {\n  const form = useForm(() => createForm({ field: "value" }))\n  const bind = createBinder(form)\n\n  return <input {...bind.input("field")} />\n}\n')),Object(o.b)("h2",{id:"optimisation"},"Optimisation"),Object(o.b)("p",null,"You can reduce the number of re-renders in big forms, by wrapping your UI blocks into the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/memo"}),Object(o.b)("inlineCode",{parentName:"a"},"<Memo />"))," component from the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/memo"}),"@corets/memo")," package. Most likely you won't ever need this, since we try to keep the render count as low as possible anyway, but if you do - we've got you covered."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import React, { useState } from "react"\nimport { createForm } from "@corets/form"\nimport { useForm } from "@corets/use-form"\nimport { Memo } from "@corets/memo"\n\nconst Example = () => {\n  const form = useForm(() => createForm({ field1: "foo", field2: "bar" }))\n  const [someValue, setSomeValue] = useState("some state")\n\n  return (\n    <form>\n      <Memo deps={form.deps("field1")}>\n        This section will only ever re-render when some of shared form properties change,\n        like: `submitting`, `submitted` or `result`, or when one of the field related properties\n        receives a change specific to this field, like: `errors`, `values`, `changedFields` or `dirtyFields`.\n      </Memo>\n\n      <Memo deps={form.deps(["field1", "field2"])}>\n        This section will change when one of the two fields receives a relevant change.\n      </Memo>\n\n      <Memo deps={form.deps(["field1", "field2"], { errors: false })}>\n        This block will NOT re-render if there is an error for one of the two fields.\n      </Memo>\n\n      <Memo deps={[...form.deps(["field1", "field2"]), someValue]}>\n        Include an aditional, custom, value to the list of dependencies for a re-render.\n      </Memo>\n    </form>\n  )\n}\n')),Object(o.b)("h2",{id:"testing"},"Testing"),Object(o.b)("p",null,"When writing unit tests, make sure that you set the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formconfig"}),Object(o.b)("inlineCode",{parentName:"a"},"debounce"))," config property to ",Object(o.b)("inlineCode",{parentName:"p"},"0"),". This will disable all the throttling of the state changes, and you will be able to write your tests in a synchronous manner."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm().config({ debounce: 0 })\n')),Object(o.b)("h2",{id:"createform"},Object(o.b)("inlineCode",{parentName:"h2"},"createForm")),Object(o.b)("p",null,"Create a new form instance:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({ data: "foo" })\n')),Object(o.b)("p",null,"Create a new form without factory function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { Form } from "@corets/form"\n\nconst form = new Form({ data: "foo" })\n')),Object(o.b)("p",null,"Create a form instance with a specific type:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\ntype MyForm = { data: string }\n\nconst form = createForm<MyForm>({ data: "foo" })\n')),Object(o.b)("p",null,"Create a new instance with a specific type inferred from initial values:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\ntype MyForm = { data: string }\n\nconst initialValues: MyForm = { data: "foo" }\nconst form = createForm(initialValues)\n')),Object(o.b)("p",null,"Specify form result type:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\ntype MyForm = { data: string }\ntype MyFormResult = { result: string }\n\nconst form = createForm<MyForm, MyFormResult>({ data: "foo" })\n')),Object(o.b)("h2",{id:"createformfromschema"},Object(o.b)("inlineCode",{parentName:"h2"},"createFormFromSchema")),Object(o.b)("p",null,"Create a new form instance based on a schema definition from the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/schema"}),"@corets/schema")," package. This is a convenience helper that allows you to avoid unnecessary boilerplate code when defining initial values for a form. Instead of creating an object, that adheres to the specific form type, with the initial values, you can define those initial values inside the schema definition itself."),Object(o.b)("p",null,"Instead of doing this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\nimport { object, string } from "@corets/schema"\n\ntype MyForm = { data: string }\ntype MyFormResult = { result: string }\n\nconst schema = object<MyForm>({\n  data: string().min(2)\n})\nconst initialValues: MyForm = { data: "foo" }\nconst form = createForm<MyForm, MyFormResult>(initialValues).schema(schema)\n\n')),Object(o.b)("p",null,"You can basically do this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createFormFromSchema } from "@corets/form"\nimport { object, value } from "@corets/schema"\n\ntype MyForm = { data: string }\ntype MyFormResult = { result: string }\n\nconst schema = object<MyForm>({\n  data: value("foo").string().min(2)\n})\nconst form = createFormFromSchema<MyForm, MyFormResult>(schema)\n')),Object(o.b)("p",null,"The two examples above are absolutely identical, just the approach is different."),Object(o.b)("h2",{id:"formconfig"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.config")),Object(o.b)("p",null,"Alter form behaviour by providing custom configuration values:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n  .config({\n    // sanitize on form submit() and validate()? (default: true)\n    sanitize: true,\n    // validate on form submit()? (default: true)\n    validate: true,\n    // validate and sanitize fields immediately after a change? (default: true)\n    reactive: true,\n    // delay invocation of listeners after a change (default: 10)\n    debounce: 10,\n  })\n')),Object(o.b)("h2",{id:"formhandler"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.handler")),Object(o.b)("p",null,"Specify a handler that is called whenever a form is submitted:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\ntype MyForm = { data: string }\ntype MyFormResult = { result: string }\n\nconst form = createForm<MyForm, MyFormResult>({ data: "foo" })\n  .handler(async (form) => {\n    // do some stuff...\n\n    const result = { some: "data" }\n\n    return result\n  })\n')),Object(o.b)("p",null,"Result returned from a handler is also returned from the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formsubmit"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.submit()"))," method and is  available through the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formgetresult"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.getResult()"))," method. A handler can be either ",Object(o.b)("inlineCode",{parentName:"p"},"sync")," or ",Object(o.b)("inlineCode",{parentName:"p"},"async"),"."),Object(o.b)("h2",{id:"formvalidator"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.validator")),Object(o.b)("p",null,"Specify a validator that is called before submission or after a field has been changed, depending on your form config:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\ntype MyForm = { data: string, nested: { field: string } }\n\nconst form = createForm<MyForm>({ data: "foo", nested: { field: "bar" } })\n  .validator(async (form) => {\n    const values = form.get()\n\n    // some validation logic\n\n    return {\n      "foo": ["Invalid value"],\n      "nested.field": ["Invalid value"]\n    }\n  })\n')),Object(o.b)("p",null,"If you happen to return validation errors for the whole form, and the validator has been invoked after a field change, errors relating to fields, that are not yet changed, will be rejected. You don't have to do anything additionally to achieve that. A validator can be either ",Object(o.b)("inlineCode",{parentName:"p"},"sync")," or ",Object(o.b)("inlineCode",{parentName:"p"},"async")," and will be called in addition to the schema that you might have configured."),Object(o.b)("h2",{id:"formschema"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.schema")),Object(o.b)("p",null,"Specify a schema that will be additionally used for validation. Schemas are available trough the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/schema"}),"@corets/schema")," package."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\nimport { object, string } from "@corets/schema"\n\ntype MyForm = { data: string, nested: { field: string } }\n\nconst schema = object({\n  data: string().min(2),\n  nested: object({\n    field: string().max(2).toTrimmed()\n  })\n})\n\nconst form = createForm<MyForm>({ data: "foo", nested: { field: "bar" } })\n  .schema(schema)\n')),Object(o.b)("p",null,"Schemas are very powerful and extremely extendable and will be called in addition to the validator that you might have configured."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Sanitizers that have been added to the schema will be called before any kind of validation happens and will alter the form values, if necessary. This only applies to the complete validation cycle and not to the reactive one (where validation is triggered when a field has changed)."),Object(o.b)("h2",{id:"formvalidate"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.validate")),Object(o.b)("p",null,"Invoking the validate method will result in a validation process where values get sanitized, schema and validator get called, resulting errors get merged, and so on:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\nimport { object, string } from "@corets/schema"\n\ntype MyForm = { data: string, nested: { field: string } }\n\nconst schema = object<MyForm>({\n  data: string().min(2),\n  nested: object({\n    field: string().max(2)\n  })\n})\n\nconst form = createForm<MyForm>({ data: "foo", nested: { field: "" } }).schema(schema)\n\nconst errors = await form.validate()\n\nif (errors) {\n  // do something with the errors\n}\n')),Object(o.b)("p",null,"Errors object will look something like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'{\n  "data": ["Must be at least \\"2\\" characters long"],\n  "nested.field": ["Required", "Must be less than \\"2\\" characters long"],\n}\n')),Object(o.b)("p",null,"You can access errors anytime later like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const errors = form.getErrors()\n")),Object(o.b)("p",null,"You can validate and sanitize only those fields that have actually been changed:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const errors = await form.validate({ changed: true })\n")),Object(o.b)("p",null,"You can disable sanitizing of values like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const errors = await form.validate({ sanitize: false })\n")),Object(o.b)("p",null,"You can control whether you want to persist any possible errors or just do a dry run and simply return the validation result:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const errors = await form.validate({ persist: false })\n")),Object(o.b)("h2",{id:"formsubmit"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.submit")),Object(o.b)("p",null,"Submitting a form will invoke the validator, schema and handler, depending on the configuration. Whatever is returned from the handler will be returned from the submit method itself and is also stored on the form object."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\ntype MyForm = { data: string }\ntype MyFormResult = { result: string }\n\nconst form = createForm<MyForm, MyFormResult>()\n  .handler(async () => {\n    return { result: "foo" }\n  })\n\nconst result = await form.submit()\n')),Object(o.b)("p",null,"You can also access the result anytime later like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const result = form.getResult()\n")),Object(o.b)("p",null,"Access validation errors:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const errors = form.getErrors()\n")),Object(o.b)("p",null,"Submit without validation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const result = form.submit({ validate: false })\n")),Object(o.b)("p",null,"Submit without sanitization:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const result = form.submit({ sanitize: false })\n")),Object(o.b)("p",null,"Submit, but validate and sanitize only changed fields:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const result = form.submit({ changed: true })\n")),Object(o.b)("h2",{id:"formlisten"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.listen")),Object(o.b)("p",null,"Subscribe to any changes on the form object:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({})\n\nconst unsubscribe = form.listen((form) => console.log("something has changed"))\n\n// unsubscribe from changes\nunsubscribe()\n')),Object(o.b)("p",null,"Invoke a listener immediately:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({})\n\nconst unsubscribe = form.listen((form) => console.log("something has changed"), { immediate: true })\n')),Object(o.b)("p",null,"Set a custom debounce interval for listener:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({})\n\nconst unsubscribe = form.listen((form) => console.log("something has changed"), { debounce: 100 })\n')),Object(o.b)("p",null,"Disable debounce for listener:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({})\n\nconst unsubscribe = form.listen((form) => console.log("something has changed"), { debounce: 0 })\n')),Object(o.b)("h2",{id:"formget"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.get")),Object(o.b)("p",null,"Get all form values:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({ data: "foo" })\nconst values = form.get()\n')),Object(o.b)("h2",{id:"formgetat"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.getAt")),Object(o.b)("p",null,"Get form values at a specific path, using the dot notation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({ nested: { data: "foo"} })\nconst value = form.getAt("nested.data")\n')),Object(o.b)("h2",{id:"formset"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.set")),Object(o.b)("p",null,"Replace all form values with the new ones:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({ data: "foo" })\n\nform.set({ data: "bar" })\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," All the values will be overwritten. This method does not track dirty and changed fields, use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formsetat"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.setAt()"))," instead."),Object(o.b)("h2",{id:"formsetat"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.setAt")),Object(o.b)("p",null,"Replace form values at a specific path, using the dot notation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({ nested: { data: "foo" } })\n\nform.setAt("nested.data", "bar")\n')),Object(o.b)("h2",{id:"formput"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.put")),Object(o.b)("p",null,"Add some data to the form by doing a merge behind the scenes:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({ data1: "foo" })\n\nform.put({ data2: "bar" })\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," This will not replace all data like ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formset"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.set()"))," does, but rather merge it. This method does not track dirty and changed fields, use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formsetat"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.setAt()"))," instead."),Object(o.b)("h2",{id:"formclear"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.clear")),Object(o.b)("p",null,"Reset form values, errors, status indicators, etc. This will reset form values to the initial values (the one that you've passed into the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#createform"}),Object(o.b)("inlineCode",{parentName:"a"},"createForm()"))," function):"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({ data: "foo" })\n\nform.clear()\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," You might want to call this after a successful form submission."),Object(o.b)("p",null,"You can also replace initial values while clearing the form:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({ data: "foo" })\n\nform.clear({ data: "bar" })\n')),Object(o.b)("h2",{id:"formgeterrors"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.getErrors")),Object(o.b)("p",null,"Get all form errors:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst errors = form.getErrors()\n')),Object(o.b)("h2",{id:"formgeterrorsat"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.getErrorsAt")),Object(o.b)("p",null,"Get all errors for at a specific path, using the dot notation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm({ nested: { data: "foo" } })\nconst errors = form.getErrors("nested.data")\n')),Object(o.b)("h2",{id:"formseterrors"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.setErrors")),Object(o.b)("p",null,"Replace all errors:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.setErorrs({\n  field: ["first error", "second error"]\n})\n')),Object(o.b)("h2",{id:"formseterrorsat"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.setErrorsAt")),Object(o.b)("p",null,"Replace all errors at a specific path, using the dot notation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.setErrorsAt("nested.field", ["first error", "second error"])\n')),Object(o.b)("h2",{id:"formadderrors"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.addErrors")),Object(o.b)("p",null,"Add some errors by doing a merge:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.addErrors({\n  field: ["first error", "second error"]\n})\n')),Object(o.b)("h2",{id:"formadderrorsat"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.addErrorsAt")),Object(o.b)("p",null,"Add some error at a specific path, by doing a merge, using the dot notation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.addErrorsAt("nested.field", ["first error", "second error"])\n')),Object(o.b)("h2",{id:"formhaserrors"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.hasErrors")),Object(o.b)("p",null,"Check if there are any errors:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst hasErrors = form.hasErrors()\n')),Object(o.b)("h2",{id:"formhaserrorsat"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.hasErrorsAt")),Object(o.b)("p",null,"Check if there are any errors at the specific path, using the dot notation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst hasErrors = form.hasErrorsAt("nested.field")\n')),Object(o.b)("h2",{id:"formclearerrors"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.clearErrors")),Object(o.b)("p",null,"Clear all errors:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.clearErrors()\n')),Object(o.b)("h2",{id:"formclearerrorsat"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.clearErrorsAt")),Object(o.b)("p",null,"Clear all errors at a specific path, using the dot notation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.clearErrorsAt("nested.field")\n')),Object(o.b)("h2",{id:"formisdirty"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.isDirty")),Object(o.b)("p",null,"Check if form values are dirty (have been written to):"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst isDirty = form.isDirty()\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Works only for fields that have been set using the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formsetat"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.setAt()"))," method. Methods like ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formset"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.set()"))," or ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formput"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.put()"))," do not track this kind of changes."),Object(o.b)("h2",{id:"formisdirtyfield"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.isDirtyField")),Object(o.b)("p",null,"Check if a specific field is dirty, using the dot notation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst isDirty = form.isDirtyField("nested.field")\n')),Object(o.b)("h2",{id:"formgetdirtyfields"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.getDirtyFields")),Object(o.b)("p",null,"Get a list of all dirty fields:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst dirtyFields = form.getDirtyFields()\n')),Object(o.b)("h2",{id:"formsetdirtyfields"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.setDirtyFields")),Object(o.b)("p",null,"Replace all dirty fields:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.setDirtyFields(["field", "nested.field"])\n')),Object(o.b)("h2",{id:"formadddirtyfields"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.addDirtyFields")),Object(o.b)("p",null,"Add some dirty fields through a merge:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.addDirtyFields(["nested.field"])\n')),Object(o.b)("h2",{id:"formcleardirtyfields"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.clearDirtyFields")),Object(o.b)("p",null,"Clear all dirty fields:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.clearDirtyFields()\n')),Object(o.b)("h2",{id:"formcleardirtyfield"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.clearDirtyField")),Object(o.b)("p",null,"Clear a specific dirty field:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.clearDirtyField("nested.field")\n')),Object(o.b)("h2",{id:"formischanged"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.isChanged")),Object(o.b)("p",null,"Check if form values have been changed:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst isChanged = form.isChanged()\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Contrary to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formisdirty"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.isDirty()")),", for a field to be tracked as changed, it's value actually has to be different from its initial state provided during the form creation. This only works for fields that have been changed trough ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formsetat"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.setAt()")),", methods like ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formset"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.set()"))," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formput"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.put()"))," do not track this kind of changes."),Object(o.b)("h2",{id:"formischangedfield"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.isChangedField")),Object(o.b)("p",null,"Check if a specific field has been changed:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst isChanged = form.isChangedField("nested.field")\n')),Object(o.b)("h2",{id:"formgetchangedfields"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.getChangedFields")),Object(o.b)("p",null,"Get all fields that have been changed:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst changedFields = form.getChangedFields()\n')),Object(o.b)("h2",{id:"formsetchangedfields"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.setChangedFields")),Object(o.b)("p",null,"Replace all changed fields:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.setChangedFields(["field", "nested.field"])\n')),Object(o.b)("h2",{id:"formaddchangedfields"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.addChangedFields")),Object(o.b)("p",null,"Add some changed fields through a merge:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.addChangedFields(["field", "nested.field"])\n')),Object(o.b)("h2",{id:"formclearchangedfields"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.clearChangedFields")),Object(o.b)("p",null,"Clear all changed fields:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.clearChangedFields()\n')),Object(o.b)("h2",{id:"formclearchangedfield"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.clearChangedField")),Object(o.b)("p",null,"Clear a specific changed field:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.clearChangedField("nested.field")\n')),Object(o.b)("h2",{id:"formgetresult"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.getResult")),Object(o.b)("p",null,"Retrieve result that have been returned from the last form submission:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst result = form.getResult()\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Result is also immediately returned from the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formsubmit"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.submit()"))," method itself."),Object(o.b)("h2",{id:"formsetresult"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.setResult")),Object(o.b)("p",null,"Replace result:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.setResult({ some: "data" })\n')),Object(o.b)("h2",{id:"formclearresult"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.clearResult")),Object(o.b)("p",null,"Clear result:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\n\nform.clearResult()\n')),Object(o.b)("h2",{id:"formissubmitting"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.isSubmitting")),Object(o.b)("p",null,"Check if form is currently submitting:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst isSubmitting = form.isSubmitting()\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Form enters this state whenever you invoke the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#formsubmit"}),Object(o.b)("inlineCode",{parentName:"a"},"Form.submit()"))," method."),Object(o.b)("h2",{id:"formsetsubmitting"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.setSubmitting")),Object(o.b)("p",null,"Set form status to ",Object(o.b)("inlineCode",{parentName:"p"},"submitting"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nform.setSubmitting(true)\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Usually you don't have to do this manually."),Object(o.b)("h2",{id:"formissubmitted"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.isSubmitted")),Object(o.b)("p",null,"Check if form has been successfully submitted at least once:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst isSubmitted = form.isSubmitted()\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Form enters this state after a successful form submission, that did not cause any validation errors nor exception from the handler."),Object(o.b)("h2",{id:"formsetsubmitted"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.setSubmitted")),Object(o.b)("p",null,"Set form status to ",Object(o.b)("inlineCode",{parentName:"p"},"submitted"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nform.setSubmitted(true)\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Usually you don't have to do this manually."),Object(o.b)("h2",{id:"formdeps"},Object(o.b)("inlineCode",{parentName:"h2"},"Form.deps")),Object(o.b)("p",null,"Returns a list of ",Object(o.b)("em",{parentName:"p"},"dependencies")," for any specific field. This is useful whenever you need to calculate whether an input field should be re-rendered or not, for example inside ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/hooks-reference.html#usememo"}),Object(o.b)("inlineCode",{parentName:"a"},"useMemo()")),", ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/hooks-reference.html#usecallback"}),Object(o.b)("inlineCode",{parentName:"a"},"useCallback()"))," or even a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/hooks-reference.html#useeffect"}),Object(o.b)("inlineCode",{parentName:"a"},"useEffect()")),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { createForm } from "@corets/form"\n\nconst form = createForm()\nconst dependenciesForOneField = form.deps("some.field")\nconst dependenciesForMultipleFields = form.deps(["some.field", "another.field"])\n')),Object(o.b)("p",null,"You can fine tune what kind of form state should be considered a dependency:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'form.deps("some.field", {\n  // form config (default: true)\n  config: true,\n  // value for that specific field (default: true)\n  values: true,\n  // dirty fields (default: true)\n  dirtyFields: true,\n  // changed fields config (default: true)\n  changedFields: true,\n  // submitting status (default: true)\n  submitting: true,\n  // submitted status (default: true)\n  submitted: true,\n  // errors for that specific field (default: true)\n  errors: true,\n  // form result (default: true)\n  result: true,\n})\n')))}void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/pages/form.mdx"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-form-mdx-1a248eea79492f64371f.js.map